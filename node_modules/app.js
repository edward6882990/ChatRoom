/* Set up Socket IO listener */
var app = require('http').createServer(handler);
var io = require('socket.io').listen(app);
var fs = require('fs');
var redis = require('redis');
var redisClient = redis.createClient();

app.listen(8080);

function handler (req, res) {
	fs.readFile(__dirname + '/index.html', function (err, data){
		if (err) {
			res.writeHead(500);
			return res.end('Error loading index.html');
		}
		res.writeHead(200);
		res.end(data);
	});
}

/* WebSocket Clients Map */
var clients      = {};

/* Redis Clients Map */
var redisClients = {};

io.on('connection', function (socket) {
	console.log(socket.id);
	/* Store a socket connection if not exists */
	if (!clients[socket.id]) clients[socket.id] = socket;

	/* Initialize a reids client for the socket connection if not done so yet */
	if (!redisClients[socket.id]) {
		redisClients[socket.id] = redis.createClient();
	}

	var redis_client = redisClients[socket.id];
	var user_name    = '';
	var chatroom_key = '';

	/* Subscribe to chat room */
	socket.on('subscribe chatroom', function (data){
		chatroom_key = 'chatroom_' + data.id;

		user_name = data.user_name

		/* Join the chatroom on NodeJS Side */
		socket.join(chatroom_key);

		/* Broadcast to all subscribed users */
		socket.broadcast.to(chatroom_key).emit('user entered', user_name);


		/* Subscribe to the chatroom's publish messages */
		console.log('subscribe: ' + chatroom_key);
		redis_client.subscribe(chatroom_key);

		/* When received a message, push back to the socket */
		redis_client.on('message', function (channel, message){
			socket.emit('received message', message);
		});
	});

	socket.on('disconnect', function() {
		/* Upon socket disconnect notify all users */
		socket.broadcast.to(chatroom_key).emit('user left', user_name);

		/* Delete the corresponding clients upon disconnect */
		clients[socket.id]      = null;
		redisClients[socket.id] = null;
	});
});
